 unix提供了5中I/O模型，如下
1.阻塞IO 最常用的模型，默认情况下，所有文件操作都是阻塞的。
2.非阻塞I/O模型， 如果缓冲区没有数据，就直接返回一个ewouldblock错误，一般都是对非阻塞I/O模型进行轮询检查这个状态，看是否有数据。
3.I/O复用模型，linux提供select/poll  进程通过将一个或者多个fd传递select或者poll系统调用，阻塞在select操作上，
这样select/poll可以帮我们查询到多个fd是否处于就绪状态，select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此他的使用
受到了一些制约，Linux还提供了一个epoll系统调用， 他是基于事件驱动方式代替顺序扫描，因此性能更高，当有fd就绪时，立即回调函数。
4.信号驱动I/O模型，
5.异步/IO  
操作系统底层都是支持异步IO通信的。

java NIO库的核心类是多路复用器selector就是基于epoll的多路复用技术实现的。


TCP以流的方式进行数据传输，上层的应用协议为了对消息进行区分，往往采用如下4种方式

1.消息长度固定，累计读到长度总和为定长len的报文后，就认为读到了一个完整的消息，将计数器置位，重新开始读取下一个数据报。
2.将回车换行作为消息结束符，例如FTP协议，这种方式在文本协议中应用比较广泛。
3.将特殊的分隔符作为消息的结束符，回车换行就是一种特殊的结束分隔符。
4.通过在消息头中定义长度字段来标识消息的总长度。

netty对上面的4种做了统一的抽象，提供了4中解码器来解决对应的问题，也不需要考虑TCP的粘包和拆包

前面演示了LineBasedFrameDecoder,

接下来演示， DelimiterBasedFrameDecoder和FixedLengthFreamDecoder,前者可以自动完成以分隔符做结束标志的消息解码器
后者可以自动完成对定长消息的解码。他们都能解决TCP粘包/拆包导致的读半包问题。